package driver

import (
	"context"
	"errors"
	"strings"
	"time"
)

/*
This JobRecord is the driver-level representation of a Job.
This is the struct that will be saved in some backend (Redis/SQL/etc...)

NOTES:
------
  - Payload is bytes only.
  - Should not import taskharbor to avoid circular deps.
*/
type JobRecord struct {
	ID             string        // Unique identifier generated by Client
	Type           string        // Used to pick the handler
	Payload        []byte        // Encoded payload bytes
	Queue          string        // Queue name
	RunAt          time.Time     // Scheduled time (0 means runnable now)
	Timeout        time.Duration // Max allowed time for Job
	IdempotencyKey string        // Allow idempotency during multiple calls (MILESTONE 6)
	CreatedAt      time.Time     // Time when Job was created
	Attempts       int           // Number of recorded failiures so far
	MaxAttempts    int           // Max total attempts allowed
	LastError      string        // Previous failiure reason
	FailedAt       time.Time     // Previous failiure time

}

/*
This is a dumb state update requested by the worker.
DRIVER MUST NOT IMPLEMENT ANY RETRY POLICIES (backoff, jitter, etc...)
*/
type RetryUpdate struct {
	RunAt     time.Time
	Attempts  int
	LastError string
	FailedAt  time.Time
}

/*
Lease token will allow the resources to be shared by the
handlers in a timely and orderly fashion.
*/
type LeaseToken string
type Lease struct {
	Token     LeaseToken
	ExpiresAt time.Time
}

/*
This function validates the JobRecord before a driver stores it.
Drivers can call this to keep behavior consistent.
*/
func (r JobRecord) Validate() error {
	if strings.TrimSpace(r.ID) == "" {
		return ErrJobIDRequired
	}
	if strings.TrimSpace(r.Type) == "" {
		return ErrJobTypeRequired
	}
	if strings.TrimSpace(r.Queue) == "" {
		return ErrQueueRequired
	}
	if r.Timeout < 0 {
		return ErrNegativeTimeout
	}
	if r.Attempts < 0 {
		return ErrNegativeAttempts
	}
	if r.MaxAttempts < 0 {
		return ErrNegativeMaxAttempts
	}
	if r.MaxAttempts > 0 && r.Attempts > r.MaxAttempts {
		return ErrAttemptsExceedMaxAttempts
	}
	return nil
}

/*
Driver is the backend contract.
*/
type Driver interface {
	Enqueue(
		ctx context.Context,
		rec JobRecord,
	) (stroredID string, existed bool, err error)
	Reserve(
		ctx context.Context,
		queue string,
		now time.Time,
		leaseFor time.Duration) (JobRecord, Lease, bool, error)
	ExtendLease(
		ctx context.Context,
		id string,
		token LeaseToken,
		now time.Time,
		leaseFor time.Duration) (Lease, error)
	Ack(ctx context.Context,
		id string,
		token LeaseToken,
		now time.Time) error
	Retry(ctx context.Context,
		id string,
		token LeaseToken,
		now time.Time,
		upd RetryUpdate) error
	Fail(ctx context.Context,
		id string,
		token LeaseToken,
		now time.Time,
		reason string) error
	Close() error
}

// Errors
var (
	ErrJobIDRequired             = errors.New("job id is required")
	ErrJobTypeRequired           = errors.New("job type is required")
	ErrQueueRequired             = errors.New("queue is required")
	ErrNegativeTimeout           = errors.New("timeout cannot be negative")
	ErrNegativeAttempts          = errors.New("attempts cannot be negative")
	ErrNegativeMaxAttempts       = errors.New("max attempts cannot be negative")
	ErrAttemptsExceedMaxAttempts = errors.New("attempts cannot exceed max attempts")

	ErrJobNotFound    = errors.New("job not found")
	ErrJobNotInflight = errors.New("job is not inflight")

	ErrInvalidLeaseDuration = errors.New("invalid lease duration")
	ErrLeaseExpired         = errors.New("lease expired")
	ErrLeaseMismatch        = errors.New("lease mismatch")
)
